# ?? Game Engine Architecture - Technical Design Document

## ?? Executive Summary

This document outlines the architecture for a **24/7 persistent world game engine** supporting **81 zones**, **guild-based territory control**, **random event spawning (Nightstorm)**, and **turn-based combat** across **Discord, Web, and Mobile platforms**.

**Design Philosophy:** Keep it simple, maintainable, and scalable. Avoid over-engineering while ensuring reliability.

---

## ??? High-Level Architecture

```
???????????????????????????????????????????????????????????????????
?                         VPS Server (Dokploy)                    ?
???????????????????????????????????????????????????????????????????
?                                                                 ?
?  ??????????????????????         ???????????????????????        ?
?  ?  Nightstorm.API    ???????????  Nightstorm.Bot     ?        ?
?  ?  (REST + SignalR)  ?   HTTP  ?  (Discord Client)   ?        ?
?  ??????????????????????         ???????????????????????        ?
?           ?                          ?                          ?
?           ?                          ? HTTP Only (No DB Access) ?
?           ?                          ?                          ?
?           ?    PostgreSQL (Shared DB - API & GameEngine Only)  ?
?           ????????????????????????????                         ?
?                           ?                                    ?
?              ???????????????????????????                       ?
?              ?  PostgreSQL Database    ?                       ?
?              ?  - Game State (Source of Truth)                 ?
?              ?  - Combat Logs (History)                        ?
?              ?  - Zone Ownership                               ?
?              ?  - Player States                                ?
?              ???????????????????????????                       ?
?                           ?                                    ?
?           ?????????????????????????????????                   ?
?           ?                               ?                   ?
?  ????????????????????????      ??????????????????????        ?
?  ? Nightstorm.GameEngine?      ?   Redis Cache      ?        ?
?  ?   (Worker Service)   ????????  - Active Combats  ?        ?
?  ?  - Zone Manager      ?      ?  - Travel Timers   ?        ?
?  ?  - Travel Manager    ?      ?  - Event Queue     ?        ?
?  ?  - Event Scheduler   ?      ??????????????????????        ?
?  ?  - Combat Manager    ?                                    ?
?  ????????????????????????                                    ?
?                                                               ?
?????????????????????????????????????????????????????????????????

   ????????????????????????????????????????????????????????
   ?  Web/Mobile Clients (Outside VPS)                    ?
   ?  - Connect to API via HTTPS                          ?
   ?  - SignalR for real-time updates                     ?
   ????????????????????????????????????????????????????????
```

**KEY SECURITY PRINCIPLE:**
- ? **Nightstorm.Bot** ? Only calls **Nightstorm.API** (HTTP/REST)
- ? **Nightstorm.API** ? Has full database access
- ? **Nightstorm.GameEngine** ? Has full database access (writes game state)
- ? **Nightstorm.Bot** ? **NEVER** accesses database directly

---

## ?? Architecture Decisions (Senior Architect Answers)

### **Decision 1: Database Strategy**

**? CHOSEN: Hybrid Approach - PostgreSQL + Redis**

| Component | Storage | Why |
|-----------|---------|-----|
| **Player State** (location, travel progress) | Redis (primary), PostgreSQL (backup every 5 min) | Fast reads/writes for 1000s of queries/sec |
| **Combat Logs** (turn-by-turn history) | PostgreSQL only | Auditing, analytics, replay functionality |
| **Zone Ownership** | PostgreSQL (primary), Redis (cached) | Changes infrequently, needs ACID compliance |
| **Active Combat State** | Redis (real-time), PostgreSQL (on completion) | Combat needs sub-second updates |
| **Nightstorm Events** | PostgreSQL (scheduled), Redis (active events) | Persistent scheduling, fast lookups |

**Why not in-memory only?**
- ? Loss of state on restart
- ? Can't scale horizontally
- ? Debugging is nightmare

**Why not PostgreSQL only?**
- ? Too slow for 81 zones × N players × 1s tick rate
- ? Database becomes bottleneck at 500+ concurrent players

**Why Redis?**
- ? 100,000+ ops/sec on cheap hardware
- ? Built-in Pub/Sub for notifications
- ? Sorted Sets perfect for travel completion timers
- ? Persistent (RDB + AOF) - survives restarts
- ? Easy to monitor and debug

---

### **Decision 2: Event Architecture**

**? CHOSEN: Hybrid - Timer-Based with Event Pub/Sub**

**Why not full Event Sourcing?**
- ? Overkill for this scale (81 zones, not 10,000 microservices)
- ? Adds complexity (event store, replay logic, versioning)
- ? Harder to debug ("which event caused this bug?")
- ? Requires team training

**Our Approach: Simple Timer-Based + Redis Pub/Sub**

```csharp
// Game Engine Worker runs background timers
while (true)
{
    // Every 1 second
    await ProcessTravelCompletions();
    await UpdateCombatTurns();
    
    // Every 5 seconds
    await UpdateZoneTreasuries();
    
    // Every 30 seconds
    await SavePlayerStatesToDatabase();
    
    await Task.Delay(1000);
}

// When state changes, publish events via Redis
await _redis.PublishAsync("game:travel:complete", new TravelCompleteEvent
{
    CharacterId = characterId,
    ZoneId = zoneId
});

// API and Bot subscribe to events
_redis.Subscribe("game:*", (channel, message) =>
{
    // Broadcast to SignalR clients
    // Send Discord notifications
});
```

**Benefits:**
- ? Simple to understand and maintain
- ? Easy to debug (just check Redis keys + PostgreSQL)
- ? No message queue infrastructure (RabbitMQ, Kafka)
- ? Redis Pub/Sub is reliable enough for our scale

---

### **Decision 3: API vs Game Engine Communication**

**? CHOSEN: Shared Database + Redis Pub/Sub (No Direct API Calls)**

**Architecture:**

```
????????????????         ??????????????????         ????????????????
? Nightstorm   ?         ?   PostgreSQL   ?         ?  Nightstorm  ?
?   .API       ???????????   (Shared)     ??????????? .GameEngine  ?
?              ?         ?                ?         ?              ?
? - Reads DB   ?         ? - Player State ?         ? - Writes DB  ?
? - REST API   ?         ? - Combat Logs  ?         ? - Game Loop  ?
? - SignalR    ?         ? - Zones        ?         ? - Events     ?
????????????????         ??????????????????         ????????????????
       ?                                                   ?
       ?                  ????????????????                ?
       ????????????????????    Redis     ??????????????????
                          ?  (Pub/Sub)   ?
                          ?              ?
                          ? - Events     ?
                          ? - Cache      ?
                          ????????????????
                                ?
                                ?
                                ? Redis Pub/Sub Only
                                ? (For notifications)
                                ?
                          ????????????????
                          ? Nightstorm   ?
                          ?   .Bot       ?
                          ?              ?
                          ? - HTTP ? API ?
                          ? - Redis Sub  ?
                          ? - NO DB!     ?
                          ????????????????
```

**Why not "Game Engine exposes API"?**
- ? Worker Service shouldn't handle HTTP requests (different concerns)
- ? Adds complexity (authentication, routing, error handling)
- ? Harder to deploy (two APIs to manage)

**Why not "API calls Game Engine directly"?**
- ? Tight coupling (API can't restart without breaking Game Engine)
- ? Synchronous blocking calls (slow)

**Why Bot NEVER accesses database directly?**
- ? **Security Risk** - Discord bot token compromise = full DB access
- ? **Bypasses API validation** - Bot could write invalid data
- ? **Bypasses authentication** - No JWT checks
- ? **Breaks single responsibility** - Bot should only handle Discord UI
- ? **Migration hell** - DB schema changes break bot

**Our Approach: Shared Database (API + GameEngine) + Event-Driven (Bot listens)**

| Scenario | How It Works |
|----------|--------------|
| **Player initiates travel (Discord)** | Bot ? API POST `/api/travel` ? API writes `PlayerState` to DB ? GameEngine picks it up |
| **Combat turn completes** | GameEngine writes to PostgreSQL ? Publishes Redis event ? Bot subscribes ? Sends Discord message |
| **Nightstorm event triggers** | GameEngine writes `NightstormEvent` to DB ? Publishes Redis event ? Bot subscribes ? Sends notification |
| **Player registers for combat (Discord)** | Bot ? API POST `/api/game/nightstorm/register` ? API validates ? Writes to DB |

**Benefits:**
- ? **Security** - Bot compromise doesn't expose database
- ? **Validation** - All data goes through API validation layer
- ? **Authentication** - Bot uses service account JWT token
- ? **Loose coupling** - Each service can restart independently
- ? **PostgreSQL is "source of truth"** (no state sync issues)
- ? **Redis Pub/Sub for real-time notifications** (fast, reliable)
- ? **Easy to add more consumers** (Web frontend, mobile app, admin panel)
